# Staging Deployment Pipeline for BookingBridge
# Automatically deploys to staging environment when staging branch is updated

name: Deploy to Staging

on:
  push:
    branches: [ staging ]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even if tests fail'
        type: boolean
        default: false

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  STAGING_URL: https://staging.bookingbridge.com

jobs:
  # Pre-deployment checks
  pre-deploy-checks:
    name: Pre-deployment Checks
    runs-on: ubuntu-latest
    
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check if deployment should proceed
        id: check
        run: |
          if [[ "${{ github.event.inputs.force_deploy }}" == "true" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "üöÄ Force deployment requested"
          else
            # Check if CI pipeline passed
            gh api repos/${{ github.repository }}/commits/${{ github.sha }}/check-runs \
              --jq '.check_runs[] | select(.name == "CI Pipeline") | .conclusion' > ci_status.txt
            
            if grep -q "success" ci_status.txt; then
              echo "should_deploy=true" >> $GITHUB_OUTPUT
              echo "‚úÖ CI pipeline passed, proceeding with deployment"
            else
              echo "should_deploy=false" >> $GITHUB_OUTPUT
              echo "‚ùå CI pipeline did not pass, skipping deployment"
            fi
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Build and push staging images
  build-staging-images:
    name: Build Staging Images
    runs-on: ubuntu-latest
    needs: [pre-deploy-checks]
    if: needs.pre-deploy-checks.outputs.should_deploy == 'true'

    permissions:
      contents: read
      packages: write

    outputs:
      backend_image: ${{ steps.backend.outputs.image }}
      frontend_image: ${{ steps.frontend.outputs.image }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push backend image
        id: backend
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile.production
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend:staging
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend:staging-${{ github.sha }}
          build-args: |
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            VERSION=staging-${{ github.sha }}
            VCS_REF=${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push frontend image
        id: frontend
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile.production
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:staging
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:staging-${{ github.sha }}
          build-args: |
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            VERSION=staging-${{ github.sha }}
            VCS_REF=${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Deploy to staging environment
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build-staging-images]
    environment: staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure kubectl
        uses: azure/k8s-set-context@v3
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.STAGING_KUBECONFIG }}

      - name: Create namespace if not exists
        run: |
          kubectl create namespace bookingbridge-staging --dry-run=client -o yaml | kubectl apply -f -

      - name: Update Kubernetes secrets
        run: |
          # Create or update secrets from GitHub secrets
          kubectl create secret generic bookingbridge-secrets \
            --namespace=bookingbridge-staging \
            --from-literal=DATABASE_URL="${{ secrets.STAGING_DATABASE_URL }}" \
            --from-literal=REDIS_URL="${{ secrets.STAGING_REDIS_URL }}" \
            --from-literal=SECRET_KEY="${{ secrets.STAGING_SECRET_KEY }}" \
            --from-literal=JWT_PRIVATE_KEY="${{ secrets.STAGING_JWT_PRIVATE_KEY }}" \
            --from-literal=JWT_PUBLIC_KEY="${{ secrets.STAGING_JWT_PUBLIC_KEY }}" \
            --from-literal=HASH_SALT="${{ secrets.STAGING_HASH_SALT }}" \
            --from-literal=FACEBOOK_APP_SECRET="${{ secrets.STAGING_FACEBOOK_APP_SECRET }}" \
            --from-literal=GOOGLE_ADS_CLIENT_SECRET="${{ secrets.STAGING_GOOGLE_ADS_CLIENT_SECRET }}" \
            --from-literal=SENDGRID_API_KEY="${{ secrets.STAGING_SENDGRID_API_KEY }}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy to staging
        run: |
          # Update image tags in Kubernetes manifests
          sed -i "s|image: bookingbridge/backend:latest|image: ${{ needs.build-staging-images.outputs.backend_image }}|g" k8s/backend-deployment.yaml
          sed -i "s|image: bookingbridge/frontend:latest|image: ${{ needs.build-staging-images.outputs.frontend_image }}|g" k8s/frontend-deployment.yaml
          
          # Apply Kubernetes manifests
          kubectl apply -f k8s/namespace.yaml
          kubectl apply -f k8s/configmap.yaml -n bookingbridge-staging
          kubectl apply -f k8s/database-deployment.yaml -n bookingbridge-staging
          kubectl apply -f k8s/backend-deployment.yaml -n bookingbridge-staging
          kubectl apply -f k8s/frontend-deployment.yaml -n bookingbridge-staging
          kubectl apply -f k8s/ingress.yaml -n bookingbridge-staging

      - name: Wait for deployment to be ready
        run: |
          kubectl rollout status deployment/bookingbridge-backend -n bookingbridge-staging --timeout=600s
          kubectl rollout status deployment/bookingbridge-frontend -n bookingbridge-staging --timeout=600s

      - name: Run database migrations
        run: |
          kubectl run migration-job-${{ github.sha }} \
            --namespace=bookingbridge-staging \
            --image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend:staging-${{ github.sha }} \
            --restart=Never \
            --env="DATABASE_URL=${{ secrets.STAGING_DATABASE_URL }}" \
            --command -- alembic upgrade head
          
          # Wait for migration to complete
          kubectl wait --for=condition=complete job/migration-job-${{ github.sha }} -n bookingbridge-staging --timeout=300s

  # Health checks and smoke tests
  staging-health-checks:
    name: Staging Health Checks
    runs-on: ubuntu-latest
    needs: [deploy-staging]

    steps:
      - name: Wait for services to be ready
        run: |
          echo "Waiting for staging environment to be ready..."
          sleep 60

      - name: Health check - Backend API
        run: |
          response=$(curl -s -o /dev/null -w "%{http_code}" ${{ env.STAGING_URL }}/api/health)
          if [ $response -eq 200 ]; then
            echo "‚úÖ Backend health check passed"
          else
            echo "‚ùå Backend health check failed (HTTP $response)"
            exit 1
          fi

      - name: Health check - Frontend
        run: |
          response=$(curl -s -o /dev/null -w "%{http_code}" ${{ env.STAGING_URL }}/health)
          if [ $response -eq 200 ]; then
            echo "‚úÖ Frontend health check passed"
          else
            echo "‚ùå Frontend health check failed (HTTP $response)"
            exit 1
          fi

      - name: API smoke tests
        run: |
          # Test API endpoints
          curl -f ${{ env.STAGING_URL }}/api/v1/businesses || exit 1
          curl -f ${{ env.STAGING_URL }}/api/v1/attribution/stats || exit 1
          echo "‚úÖ API smoke tests passed"

      - name: Database connectivity test
        run: |
          response=$(curl -s ${{ env.STAGING_URL }}/api/health)
          if echo "$response" | grep -q "database.*healthy"; then
            echo "‚úÖ Database connectivity test passed"
          else
            echo "‚ùå Database connectivity test failed"
            echo "Response: $response"
            exit 1
          fi

  # Run staging tests
  staging-tests:
    name: Staging Integration Tests
    runs-on: ubuntu-latest
    needs: [staging-health-checks]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install test dependencies
        run: |
          npm install -g playwright
          npx playwright install --with-deps

      - name: Run staging integration tests
        run: |
          npx playwright test --config=playwright.staging.config.js
        env:
          BASE_URL: ${{ env.STAGING_URL }}

      - name: Upload test results
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: staging-test-results
          path: test-results/
          retention-days: 7

  # Notify deployment results
  notify-deployment:
    name: Notify Deployment Results
    runs-on: ubuntu-latest
    needs: [deploy-staging, staging-health-checks, staging-tests]
    if: always()

    steps:
      - name: Notify success
        if: ${{ needs.deploy-staging.result == 'success' && needs.staging-health-checks.result == 'success' && needs.staging-tests.result == 'success' }}
        run: |
          echo "üöÄ Staging deployment successful!"
          echo "Staging URL: ${{ env.STAGING_URL }}"

      - name: Notify failure
        if: ${{ needs.deploy-staging.result == 'failure' || needs.staging-health-checks.result == 'failure' || needs.staging-tests.result == 'failure' }}
        run: |
          echo "‚ùå Staging deployment failed!"
          exit 1

      - name: Create deployment status
        uses: actions/github-script@v6
        with:
          script: |
            const success = '${{ needs.deploy-staging.result }}' === 'success' && 
                           '${{ needs.staging-health-checks.result }}' === 'success' && 
                           '${{ needs.staging-tests.result }}' === 'success';
            
            github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: context.payload.deployment?.id || 0,
              state: success ? 'success' : 'failure',
              environment_url: '${{ env.STAGING_URL }}',
              description: success ? 'Deployment successful' : 'Deployment failed'
            });

  # Rollback on failure
  rollback-on-failure:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: [deploy-staging, staging-health-checks, staging-tests]
    if: failure()
    environment: staging

    steps:
      - name: Configure kubectl
        uses: azure/k8s-set-context@v3
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.STAGING_KUBECONFIG }}

      - name: Rollback deployment
        run: |
          echo "Rolling back staging deployment..."
          kubectl rollout undo deployment/bookingbridge-backend -n bookingbridge-staging
          kubectl rollout undo deployment/bookingbridge-frontend -n bookingbridge-staging
          
          # Wait for rollback to complete
          kubectl rollout status deployment/bookingbridge-backend -n bookingbridge-staging --timeout=300s
          kubectl rollout status deployment/bookingbridge-frontend -n bookingbridge-staging --timeout=300s
          
          echo "‚úÖ Rollback completed"